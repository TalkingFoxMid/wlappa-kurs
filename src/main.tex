\documentclass[14pt]{extarticle}

%Russian-specific packages
%--------------------------------------
\usepackage[russian]{babel}
%--------------------------------------

%Hyphenation rules
%--------------------------------------
\usepackage{hyphenat}
%--------------------------------------
\usepackage{listings}
%Math
%--------------------------------------
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{accents}
\usepackage{systeme}
\usepackage{array}
\usepackage{circuitikz}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\sign}{sign}
\newcommand\aug{\fboxsep=-\fboxrule\!\!\!\fbox{\strut}\!\!\!}
\newcommand{\setcomp}[1]{\overline{#1}}
\newcommand{\non}[1]{\overline{#1}}
\newcommand{\xor}{\oplus}
\usepackage{diagbox}
%--------------------------------------

%Graphics
%--------------------------------------
\usepackage{graphicx, caption}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{tikz}
\usepackage{booktabs}
\usetikzlibrary{tikzmark}
\newcommand\tm\tikzmark
%--------------------------------------

%errors fix
%--------------------------------------
\usepackage{microtype}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{verbatim}
% \renewcommand{\thesubsection}{\thesection\alph{subsection}}
\setlength{\parindent}{0em}
\setlength{\parskip}{\baselineskip}%
%--------------------------------------
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
}

\begin{document}

    \tableofcontents
    \newpage

    \section{Введение}

    Цель данной работы --- разработать бэкэнд-сервис, решающий общие задачи клиентов, в частности задачу авторизации.

    Необходимость существования такого сервиса возникла в процессе разработки распределенного приложения для
    обслуживания многопользовательских игр.
    Разрабатываемое приложение использует микросервисную архитектуру, а клиенты должны иметь возможность
    взаимодействовать с различными сервисами системы.
    Но для того, чтобы такое взаимодействие было возможно, необходимо предоставить клиентам возможность обнаруживать
    эти сервисы, а подход, при котором клиент хранит адреса всех таких сервисов, имеет множество недостатков,
    поскольку местоположение сервисов может постоянно меняться. Также,
    существует проблема валидации пользователей.
    Сервисы должны уметь
    понимать, что пользователь является тем, за кого себя выдает. Для этого пользователям нужно выдавать ключи,
    которые бы подтверждали их личность.
    Для решения подобного рода задач был спроектирован сервис API.

    В имеющейся модели сервис API представляет собой распределенный, легко реплицируемый сервис без внутреннего
    состояния (stateless-сервис), с которым взаимодействует веб-клиент.

    Для написания сервиса API был выбран язык Scala\cite{scala}, поскольку он предназначен для написания
    stateless-сервисов ввиду применения в нём функциональной парадигмы программирования, базирующейся на неизменяемых структурах.

    Главная задача, которую предполагалось решить в рамках данной работы, --- разработка сервиса API на языке Scala и реализация механизма авторизации клиентов в рамках полученного сервиса.

    Задача была успешно решена. В данной работе рассказано, почему Scala является подходящим языком для решения поставленной задачи. 
    Приводятся сравнения и описания различных технологий, фреймворков для функционального программирования, библиотек для написания HTTP-серверов. 
    Также в работе описана рабочая и надёжная модель авторизации на основе JWT-токенов, описаны её преимущества и недостатки.


    \section{Преимущества языка Scala для написания сервисов без состояния}

    Язык Scala обладает большими преимуществами, когда речь заходит о сервисах без состояния. Язык Scala исполняется
    на виртуальной машине Java.

    В приложениях, написанных на языке Scala, распространены
    техники, не отличающиеся высокой производительностью. Например, принято оборачивать все функции, не являющиеся
    чистыми, в специальную монаду IO \cite{monad}, за счет чего такие функции становятся более тяжелыми для исполнения
        (создаём
    больше объектов, переключаем контексты, лишние операции для композиции монад). Также, существенно влияет на
    скорость тот факт, что объекты, которые мы однажды создали, уже не могут быть изменены. А потому, когда возникает
    необходимость получить объект, лишь чуть отличающийся от уже имеющегося, виртуальной машине Java приходится
    копировать этот имеющийся объект, поскольку просто изменить не позволяет стандарт языка Scala.
    Несмотря на это, язык Scala позволяет
    легко создавать распределенные
    системы, именно за счет
    специфической
    философии
    функциональных языков, богатой библиотеки, построенной поверх неё.

    Функциональный стиль позволяет нам создавать HTTP обработчики в декларативном стиле \cite{decl}, что делает бизнес код
    легко
    читаемым, понятным даже тому, кто слабо знаком с языком. Это достигается именно за счет того, что синтаксис,
    применяемый в
    методах и
    алгоритмах, описанных на Scala, очень близок к тому, что используется в натуральных языках. \cite{declnat}

    \subsection{Эффективное программирование на Scala (ZIO, Cats...)}

    Scala сильно отличается от ООП языков способом описания бизнес логики.

    Основное отличие - стремление обернуть все эффекты монадой IO для того, чтобы добиться чистоты всех функций.

    Есть различные библиотеки, которые позволяют делать это (ZIO, Cats, Monix и др.)

    В этом проекте было решено использовать ZIO\cite{zio}  в качестве основного функционального фреймворка.

    \subsection{Коротко про ZIO}
    Основная сущность, предоставляемая фреймворком, --- монада IO (которая в самой библиотеке представлена интерфейсом ZIO).

    На монаду ZIO можно смотреть как на типизированный контейнер с тремя свободными типами, способный содержать некоторый эффект.

    \begin{verbatim}
        sealed trait ZIO[-R, +E, +A]
    \end{verbatim}

    R - требуемый контекст. Можно сказать, набор интерфейсов, которые должны иметься у Runtime (cущность, позволяющая
    запустить ZIO монаду).

    E - тип возможной ошибки, которая может возникнуть при запуске ZIO

    A - Тип результата вычисления ZIO, который будет получен после вычисления.

    В ZIO можно положить уже вычисленное значение, можно значение, которое еще не вычислено (отложенное вычисление,
    описанное функцией).

    \begin{verbatim}
        Положили число:
        ZIO.succeed(5)

        Положили вычисление, синус будет вычислен в момент запуска ZIO
        ZIO.effect(math.Sin(10))

        Положили эффект вывода числа 10 в консоль.
        ZIO.effect(println(10)) --
    \end{verbatim}

    ZIO является монадой, то есть у него доступна операция flatMap. С помощью неё можно склеивать вычисления. Например:

    \begin{verbatim}
        def sin(x: Double) = ZIO(math.Sin(x))
        def cos(x: Double) = ZIO(math.Cos(x))

        val zioSin: ZIO[Any, Nothing, Double] = sin(4)


        val zioCos: ZIO[Any, Nothing, Double] =
            zioSin.flatMap(result => cos(result))
    \end{verbatim}


    \section{Написание HTTP сервера на Scala}
    Инфраструктура HTTP сервера на Scala состоит из трех основных частей:

    \subsection{Описания языка для декларации обработчиков запросов}

    В языке Scala принято  разделять язык и логику, которая за ним стоит. Это является частным случаем абстракции.
    В Scala все языки принято делать декларативными, то есть в языке можно выделить некоторые выражения, которые
    получаются путем других выражений. Такой подход к написанию языков имеет много общего с типизированным лямбда
    исчислением.

    Такой язык также принято называть DSL. Впоследствии будем пользоваться именно этим термином.

    В создании DSL в первую очередь важны удобность, гибкость, надежность и
    предсказуемость. Некоторые из этих вещей, в частности надежность и предсказуемость, частично обеспечиваются строгой
    типизацией и
    неизменяемостью.
    сущностей
    Но также важно, чтобы DSL не ограничивал возможности разработчиков, был гибок и универсален.


    Огромное значение стоит придать удобности описания новых сервисов, компактности нашего DSL.
    \newpage
    \subsection{Низкоуровневый HTTP сервер (HTTP engine)}

    В первую очередь имеет смысл обращать внимание на 3 показателя:

    \begin{enumerate}
        \item HTTP сервер должен быть производительным.
        \item Библиотека, поверх которой он написан, должна быть поддерживаемая.
        \item Библиотека должна быть хорошо совместимой с другими библиотеками, используемыми в нашем проекте (гибкость,
        универсальность, легкость интеграции с произвольным DSL).
    \end{enumerate}

    \subsection{Инструмент конвертации описанного нами DSL в язык HTTP сервера}
    Здесь в первую очередь важно, чтобы технологии, выбранные в двух пунктах выше, были совместимыми между собой.

    \section{Выбор HTTP движка}

    Есть множество библиотек, позволяющих написать HTTP сервер на Scala.

    Самые известные: Akka, Vert.X, Http4s, Finagle.

% Или здесь, или дальше при описании каждой из библиотек, напрашиваются
% ссылки на сайты

    \subsection{Akka}
    Akka оказалась не подходящей, поскольку данный фреймворк является крайне устаревшим, использует в качестве ядра выполнения
    запросов такие сущности как Futures. Futures --- контейнер поверх некоторого вычисления, которое может быть
    произведено на другом потоке (не на том, на котором была создана Future). Позже результат такого вычисления можно
    обработать.

    Future на данный момент считается устаревшей технологией. Её основной недостаток перед ZIO и другими
    современными функциональными фреймворками состоит в том, что
    вычисление содержимого Future всегда привязано к некоторому потоку, в то время как в ZIO вычисление производится
    на виртуальных потоках, более легковесных. Также вычисление, размещенное во Future, начинает выполняться сразу,
    что в некоторых случаях сильно противоречит идеям неизменяемости сущностей. Ведь только созданная Future, ещё не
    вычисленная, это не то же самое, что уже вычисленная Future.

    Также, важным минусом Akka является то, что она не является самой быстрой библиотекой.

    С другой стороны Akka не лишена преимуществ: она совместима со множеством других библиотек, является крайне
    универсальной.

    \subsection{Vert.X}
    Vert.X, вероятно, самая быстрая библиотека для Http сервера. Однако, она обладает одним огромным недостатком. 
    Vert.X - пришла из Java, а потому имеет не очень высокую совместимость со Scala, с функциональной парадигмой.
    Vert.X очень низкоуровневая библиотека.
    
    \subsection{Finagle}
    Крайне быстрая, универсальная библиотека, разработанная компанией Twitter. Но она, как и Vert.X, является очень
    низкоуровневой, процедурной, и к тому же слабо задокументированной, довольно сложной для использования.
    
    \subsection{Http4s}
    Надежная, функциональная, удобная для использования библиотека. Однако, Http4s, в сравнении с другими библиотеками,
    является слишком медленной. Именно поэтому, Http4s не принято использовать для высоконагруженных серверов.
    
    \subsection{ZIO-Http}

    ZIO-Http новое, но пока не очень популярное в мире Scala решение,
    предоставляющее удобный
    функциональный
    интерфейс, а
    также, по проводимым сравнениям, обладающее очень высокой производительность.

    Было решено попробовать в качестве библиотеки для сервера ZIO-Http. Основная причин выбора: очень высокая
    совместимость с ZIO, новизна, высокая производительность.


    \section{Язык описания HTTP}

    В качестве библиотеки для описания DSL решили взять Tapir \cite{tapir}.

    Нельзя сказать, что это был лучший выбор, поскольку Tapir --- одна из тех библиотек, которая настаивает на том,
    чтобы разработчики, которые её используют, придерживались синтаксиса, идей и философии, которые предлагает нам
    эта библиотека.

    Tapir --- не очень гибкое решение, и требует от разработчика, который захочет сделать на её основе свой DSL, больших
    стараний.

    Был альтернативный вариант --- Typed Schema \cite{ts}. (Одна из немногих HTTP DSL библиотек, совместимых с ZIO-http.)

    Эта библиотека, наоборот, является очень гибкой. Возможно, даже слишком. Она позволяет создавать любые DSL,
    которые только пожелает разработчик. Однако, главный минус Typed Schema --- сложность. Она требует от разработчика
    мастерства, в то время как Tapir обещает простоту использования, конфигурации и настройки.

    \newpage
    \subsection{Связь Tapir + ZIO http}

    Библиотека Tapir, к счастью, имеет крайне проработанную интеграцию с ZIO HTTP. То есть, существуют механизмы, позволяющие
    отображать описания обработчиков с помощью Tapir в сервер ZIO http. Однако, здесь может возникнуть задача сделать такое отображение
    максимально удобным, чтобы код стал расширяемым, понятным.

    Основная сущность, которой оперирует Tapir - Endpoint:

    Endpoint - абстракция над HTTP обработчиком, предоставляемая библиотекой Tapir. Фактически, endpoint представляет из себя
    некоторое общее описание обработчика. То есть, тип метода (GET, POST), аргументы метода, тип возвращаемого результата, и так далее.

    \begin{verbatim}
        case class Endpoint[I, E, O, -R](input: EndpointInput[I],
            errorOutput: EndpointOutput[E],
            output: EndpointOutput[O],
            info: EndpointInfo)
    \end{verbatim}

    Endpoint описывает REST endpoint прослушивающего сервера.
    I - тип сущности, которую прислал нам клиент
    E - тип бизнес ошибки, которая может прийти клиенту
    O - тип сущности, которую клиент получит от сервера в ответ на запрос
    R - тип контейнера, в котором переносятся данные
% надо оформить как список
    Определение endpoint в tapir имеет следующий вид:
    \begin{verbatim}
        private val sum = endpoint
            .in("sum")
            .in(query[Int]("x"))
            .in(query[Int]("y"))
            .out(stringBody)
    \end{verbatim}

    Таким образом определяется endpoint, который лежит по адресу \textbf{/sum}, принимает два параметра, имеющих тип
    Int, и
    возвращает клиенту строку.

    Логика здесь не описана. Фактически, tapir занимается лишь определением интерфейсов. Такой подход позволяет в том числе
    автоматически построить Swagger, документацию доступных HTTP методов нашего сервиса.

    Логика определяется отдельно.

    После создания EndPoint из Tapir, имеется возможность сконвертировать его в формат,
    используемый в сервере ZIO-Http.

    Для этого можно воспользоваться сущностью ZioHttpInterpreter, которая является частью библиотеки Tapir.

    Пример создания tapir endpoint и последующей конвертации его в ZIO HTTP Endpoint:

    \begin{verbatim}
    private val tapirEndpoint = endpoint
        .in("path")
        .in(query[Int]("x"))
        .in(query[Int]("y"))
        .out(stringBody)

    private val zioEndpoint = ZioHttpInterpreter().toHttp(tapirEndpoint) {
      case (x, y) => Task {
        Right((x + y).toString)
      }
    }
    \end{verbatim}

    После создания zioEndpoint, необходимо сделать вызов:

    \begin{verbatim}
        Server.start[Blocking](config.port, zioEndpoint)
    \end{verbatim}

    После этого fiber (легковесный поток вычисления содержимого ZIO контейнера), в котором запущен сервер,
    блокируется, начинает заниматься асинхронной обработкой входящих запросов.

    Endpoint-ы можно складывать, получать новые endPoint-ы, с помощью которых можно обрабатывать запросы разных типов.

    \section{Модель авторизации}

    Для того, чтобы
    многопользовательские игры были
    возможны, имели хоть какой-то смысл, необходимо уметь различать пользователей, взаимодействующих с системой,
    как-то проверять, что это настоящий пользователь. Именно для этого необходима аутентификация.

    Стоит также сказать о том, что процесс подтверждения личности должен быть децентрализованным. То есть каждый
    микросервис должен осуществлять этот процесс.

    Один из способов обеспечить такой механизм --- JWT токен. \cite{jwt}

    JWT токен --- некоторая информация, пописанная цифровой подписью (сигнатурой) с помощью симметричного шифрования.
    Для шифрования используется ключ, известный всем сервисам. Создание такого токена, как и проверка его
    достоверности (процесс подписи некоторых
    данных), требует знания этого секретного ключа.

    Таким образом, аутентификацию пользователя можно организовать следующим образом:

    1) Один из экземпляров нашего API предоставляет клиентам операции регистрации и логина.

    2) После того, как клиент ввел свои реквезиты на нашем API, ему выдается вечный токен.

    3) С помощью этого токена, он способен получить на любой другом узле свой JWT.

    4) JWT может быть использован как ключ, позволяющий пользователю доказать свою подлинность.

    \subsection{Причины использовать несколько токенов}

    В разрабатываемой модели авторизации, можно было бы обойтись лишь одним токеном, но это
    понесло бы за
    собой много минусов и ограничений.

    \subsection{Почему нельзя обойтись только вечным токеном?}

    Основная проблема состоит в том, что подтверждение достоверности представленного пользователем вечного токена
    осуществляется путем совершения запроса к базе данных. Был расчет на то, что каждый запрос к нашей системе
    должен сопровождаться подтверждением своей личности со стороны пользователя. То есть, каждое обращение
    пользователя к сервису вынуждало бы этот сервис обращаться к базе данных. Это сделало бы запросы к сервису более
    медленными и добавило бы лишнюю нагрузку на базу.

    \subsection{Почему нельзя обойтись только JWT токеном?}

    Была возможность получать JWT токен не по вечному, а по логину и паролю, то есть также, как вечный токен. Но это
    создало бы следующую проблему: нет возможности инвалидировать все сессии без смены пароля.

    То есть, если бы у нас не было вечного токена, нам было бы сложнее управлять пользовательскими сессиями.

    \subsection{Недостатки JWT токена}
    Основной недостаток состоит в том, что, захватив секретный ключ, с помощью которого генерируются JWT-токены,
    злоумышленник получит доступ к нашей системе, сможет обращаться к сервисам от лица любого из пользователей.

    \subsection{Структура JWT токена}

    JWT токен представляет собой строку, состоящую из трех частей.

    1) Метаинформация.
    Здесь описана некоторая информация вроде алгоритма шифрования.
    Обычно используется HS256.

    2) Бизнес информация.
    Здесь можно разместить любую информацию, которую необходимо обернуть в JWT токен и подписать.

    3) Сигнатура верификации.
    Это цифровая подпись. Она представляет собой некоторый набор символов, построенный API по бизнес
    информации с использованием приватного ключа. С помощью сигнатуры верификации и публичного ключа, который
    известен всем, можно убедиться в том, что информация, обернутая в наш токен, не была подделана.

    Например, в Api в JWT токен оборачивается пара значений: идентификатор пользователя и время истечения токена.
    Таким образом,
    пользователь, обладающий таким токеном, может подтверждать свою личность
    (поскольку токен выдан на его имя). А время истечения токена позволяет достичь кратковременности таких
    токенов, то есть злоумышленник, получивший доступ к JWT токену, не сможет использовать его дольше заданного
    времени.
    Попытка подделать время истечения будет легко замечена с помощью цифровой подписи.

    \section{Реализация авторизации на стороне API}

    На стороне API нам предстояло реализовать несколько методов, позволяющих клиенту получить его JWT токен,
    чтобы с ним обращаться к другим микросервисам, доказывая свою подлинность.

    В API было решено выделить следующие методы:
    \begin{enumerate}
        \item registerEndpoint
            Клиент может зарегистрироваться (с некоторым логином и паролем).
        \item loginEndpoint
            Клиент может войти в систему (с некоторым логином и паролем).
            Он получает новый сгенерированный вечный токен.
        \item obtainEndpoint
        Клиент может получить JWT токен, воспользовавшись ранее полученным Eternal Token.
    \end{enumerate}

    \subsection{Endpoint - Register}

    \begin{verbatim}
        private val registerEndpoint: EndpointCollector = endpointE[RegisterError].post
            .in("register")
            .in(jsonBody[RegisterRequest])
            .build(req => service.registerUser(req.userName, req.password))(_ => ())
    \end{verbatim}

    Определили следующий EndpointCollector.
    Он ожидает POST-запрос, имеет префикс "register", принимает некоторый json вида RegisterRequest.
    В build вызывается service.registerUser c именем клиента и его паролем.

    Логика, вызываемая в обработчике следующая:

    1) Валидируем формат пароля

    2) Получаем хэш пароля

    3) Генерируем случайный UUID, идентификатор нового пользователя

    4) Пытаемся добавить в базу запись вида (UUID, login, password\_hash)

    Если возникает ошибка UNIQUE\_VIOLATION (попытались добавить юзера с уже занятым логином),
    возвращаем клиенту бизнес ошибку (логин занят).

    \subsection{Метод регистрации в нашем сервисе - service.registerUser}
    \begin{verbatim}
        def registerUser(userName: UserName, password: Password): Task[Unit] =
            for {
              _            <- validatePasswordFormat(password)
              passwordHash <- encrypt(password)
              uuid         <- generator.randomUUID
              regResult    <- repo.registerUser(uuid, userName, passwordHash)
            } yield regResult
    \end{verbatim}

    \subsection{Метод регистрации в репозитории - repo.registerUser}
    \begin{verbatim}
        def registerUser(uuid: UUID, userName: UserName, passwordHash: PasswordHash): Task[Unit] =
            sql"insert into user_credentials(id, username, password) values ($uuid, $userName, $passwordHash)".update.run.endSQLCatch {
              case sqlstate.class23.UNIQUE_VIOLATION => UserNameIsTaken
            }.void
    \end{verbatim}

    \subsection{Endpoint - Login}
    \begin{verbatim}
            private val loginEndpoint = endpointE[LoginError].post
                .in("login")
                .in(jsonBody[LoginRequest])
                .out(setCookies)
                .buildWithCookie(req => service.login(req.userName, req.password))(("eternal", _))
    \end{verbatim}

    1) Достаем из базы uuid пользователя с таким логином, хэш его пароля.

    2) Валидируем пришедший пароль, сравнивая с хэшом.

    3) Генерируем случайный вечный токен

    4) Кладем его в базу и возвращаем пользователю.

    \subsection{Метод логина в нашем сервисе - service.login}
    \begin{verbatim}
            override def login(userName: UserName, password: Password): Task[EternalToken] =
                for {
                  UserData(uuid, _, hash) <- repo
                    .getUserDataByName(userName)
                    .mapError(_ => WrongLoginOrPassword)
                  _ <- validateOrFail(password, hash)
                    .mapError {
                      case WrongPassword | WrongLogin => WrongLoginOrPassword
                      case e                          => e
                    }
                  eternalToken <- generator.randomEternalToken
                  _            <- repo.putEternalToken(uuid, eternalToken)
                } yield eternalToken
    \end{verbatim}

    \subsection{Endpoint - Obtain}
    \begin{verbatim}
            private val obtainEndpoint: EndpointCollector = endpointE[ObtainError].get
                .in("obtain_jwt")
                .in(cookie[EternalToken]("eternal"))
                .out(setCookies)
                .buildWithCookie(service.obtainSession)(("jwt", _))
    \end{verbatim}

    1) Достаем из базы UUID пользователя.

    2) Строим для этого пользователя JWT токен, а затем возвращаем его.

    \subsection{Метод получения сессии - service.obtainSession}
    \begin{verbatim}
            override def obtainSession(eter: EternalToken): Task[JwtToken] =
                for {
                  userId   <- repo.userIdByEternalToken(eter)
                  jwtToken <- jwtAuthService.buildToken(userId)
                } yield jwtToken
    \end{verbatim}

    \section{Процесс авторизации:}

    В итоге получаем схему, в которой, чтобы воспользоваться приложением, пользователь должен сначала
    зарегистрироваться методом Register, оставить в нашей базе данных свой логин и хэш пароля, а также случайный уникальный
    идентификатор.

    Затем, воспользовавшись логином и паролем, он может обратиться к методу Login, получить длительную сессию, так
    называемый вечный токен. Этот токен лежит в базе и позволяет пользователю, которому он принадлежит, получить свою
    кратковременную сессию, то есть JWT.

    Процесс получения JWT состоит в том, что пользователь обращается к методу Obtain, передавая свой вечный токен, а
    на что ему возвращается JWT, который предоставляет клиенту доступ к прочим сервисам.

    \section{Заключение}

    В ходе выполнения работы удалось изучить современные решения способов написания HTTP серверов без состояния на
    языке Scala.

    Также удалось поработать над моделью авторизации, изучить распространенные подходы к её описанию, попробовать
    реализовать её на практике.

    \begin{thebibliography}{99}
        \bibitem{scala}
        Scala [электронный ресурс] // \url{https://www.scala-lang.org} (дата обращения 31.01.2022)

        \bibitem{monad}
        Understanding IO Monad in Scala [электронный ресурс] //
        \url{https://medium.com/walmartglobaltech/understanding-io-monad-in-scala-b495ca572174}
        (дата обращения 31.01.2022)

        \bibitem{decl}
        Декларативный стиль [электронный ресурс] // \url{https://www.toptal.com/software/declarative-programming}
        (дата обращения 31.01.2022)

        \bibitem{declnat}
        Declarative Programming and Natural Language [электронный ресурс] // \url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.7029&rep=rep1&type=pdf}
        (дата обращения 31.01.2022)

        \bibitem{zio}
        ZIO [электронный ресурс] // Режим доступа \url{https://github.com/dream11/zio-http} (дата обращения 31.01.2022)

        \bibitem{tapir}
        Tapir [электронный ресурс] // Режим доступа \url{https://github.com/softwaremill/tapir} (дата обращения 31.01.2022)

        \bibitem{ts}
        Typed schema [электронный ресурс] // \url{https://github.com/Tinkoff/typed-schema} (дата обращения 31.01.2022)

        \bibitem{jwt}
        JWT //
        \url{https://jwt.io/introduction}
        (дата обращения 31.01.2022)

    \end{thebibliography}

\end{document}