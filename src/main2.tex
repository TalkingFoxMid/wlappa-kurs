\documentclass[14pt]{extarticle}

%Russian-specific packages
%--------------------------------------
\usepackage[russian]{babel}
%--------------------------------------

%Hyphenation rules
%--------------------------------------
\usepackage{hyphenat}
%--------------------------------------
\usepackage{listings}
%Math
%--------------------------------------
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{accents}
\usepackage{systeme}
\usepackage{array}
\usepackage{circuitikz}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\sign}{sign}
\newcommand\aug{\fboxsep=-\fboxrule\!\!\!\fbox{\strut}\!\!\!}
\newcommand{\setcomp}[1]{\overline{#1}}
\newcommand{\non}[1]{\overline{#1}}
\newcommand{\xor}{\oplus}
\usepackage{diagbox}
%--------------------------------------

%Graphics
%--------------------------------------
\usepackage{graphicx, caption}
\usepackage{subcaption}
\usepackage[absolute,overlay]{textpos}
\usepackage{wrapfig}
\usepackage{tikz}
\usepackage{booktabs}
\usetikzlibrary{tikzmark}
\newcommand\tm\tikzmark
%--------------------------------------

%errors fix
%--------------------------------------
\usepackage{microtype}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{verbatim}
% \renewcommand{\thesubsection}{\thesection\alph{subsection}}
\setlength{\parindent}{0em}
\setlength{\parskip}{\baselineskip}%
%--------------------------------------
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
}
\setcounter{tocdepth}{1}
\usepackage{indentfirst}
\setlength\parindent{1.5em}
\begin{document}
    \thispagestyle{empty}
    \begin{center}
        \textbf{Министерство науки и высшего образования Российской Федерации}

        \textbf{ФГАОУ ВО «УрФУ имени первого Президента России Б.Н. Ельцина»}
        Кафедра «школы бакалавриата (школа)»
    \end{center}
    \begin{textblock*}{10cm}(10cm,6.5cm)
        \begin{center}
            Оценка работы \underline{\hspace{1cm}}

            Руководитель от УрФУ Клепинин А.В.
        \end{center}
    \end{textblock*}
    \begin{textblock*}{10cm}(6cm,10cm)

        \begin{center}
            Тема задания на практику
            \linebreak

            \textbf{Разработка HTTP сервиса на языке Scala, поддерживающего механизмы аутентификации и авторизации}
            \linebreak
            \linebreak
            ОТЧЕТ

            Вид практики Научно-исследовательская работа

            Тип практики Производственная практика, научно-исследовательская работа

        \end{center}
    \end{textblock*}
    \begin{textblock*}{16cm}(3cm,20cm)

        \begin{flushleft}
            Руководитель практики от предприятия (организации) Клепинин А.В.
            \linebreak\linebreak
            Студент Башкаров И.А.
            \linebreak\linebreak
            Специальность (направление подготовки) 02.03.01 Математика и компьютерные
            науки
            \linebreak\linebreak
            Группа МЕН - 390206
        \end {flushleft}
    \end{textblock*}
    \begin{textblock*}{16cm}(10cm,27cm)
        Екатеринбург 2021
    \end{textblock*}
    \pagebreak

    \tableofcontents
    \newpage
    \section{Введение}

    Цель данной работы --- разработать бэкэнд-сервис, решающий общие задачи клиентов, в частности задачи аутинтификации и авторизации.

    Необходимость существования такого сервиса возникла в процессе разработки распределенного приложения для
    обслуживания многопользовательских игр.
    Разрабатываемое приложение использует микросервисную архитектуру, а клиенты должны иметь возможность
    взаимодействовать с различными сервисами системы.
    Но для того, чтобы такое взаимодействие было возможно, необходимо предоставить клиентам возможность обнаруживать
    эти сервисы. При этом, алгоритм обнаружения должен быть маскимально эффективным.
    Также, будет уделено внимание валидации пользователей. Сервисы должны уметь определять, является ли пользователь тем,
    за кого себя выдает, после чего предоставлять ему все необходимые права.

    Для решения подобного рода задач был спроектирован сервис API.

    В имеющейся модели сервис API представляет собой распределенный, легко реплицируемый сервис без внутреннего
    состояния (stateless-сервис), с которым взаимодействует веб-клиент.

    Для написания сервиса API был выбран язык Scala\cite{scala}, поскольку он предназначен для написания
    stateless-сервисов ввиду применения в нём функциональной парадигмы программирования, специализирующийся на написаниях сервисов без состояния.

    Главная задача, которую предполагалось решить в рамках данной работы, ---
    разработка сервиса API на языке Scala и реализация механизмов аутентификации и авторизации клиентов в рамках полученного сервиса.

    Задача была успешно решена. В данной работе описано, почему Scala является подходящим языком для решения поставленной задачи.
    Приводятся сравнения и описания различных технологий, фреймворков для функционального программирования, библиотек для написания HTTP-серверов.
    Также в работе описана надёжная модель авторизации на основе JWT-токенов, описаны её преимущества, недостатки, альтернативы.

    \section{Преимущества языка Scala для написания сервисов без состояния}

    Язык Scala обладает большими преимуществами, когда речь заходит о сервисах без состояния. Это достигается за счет
    использования неизменяемых структур. Сервисом без состояния называется такой приложение, которое не имеет внутреннего состояния,
    которое влияло бы на его поведение.

    В приложениях, написанных на языке Scala, распространены
    техники, не отличающиеся высокой производительностью. Например, принято оборачивать все функции, не являющиеся
    чистыми, в специальный контейнер IO\cite{monad}, о чем позже будет рассказано чуть подробнее,
    за счет чего такие функции становятся более тяжелыми для исполнения ввиду создания дополнительных служебных объектов.
    Также, существенно влияет на
    скорость тот факт, что объекты, которые однажды были создали, уже не могут быть изменены. А потому, когда возникает
    необходимость получить объект, отличающийся от уже имеющегося, виртуальной машине Java приходится
    копировать этот имеющийся объект, поскольку просто изменить не позволяет стандарт языка Scala.
    Несмотря на это, язык Scala позволяет
    легко создавать распределенные
    системы, именно за счет
    специфической
    философии
    функциональных языков, а также возможности использовать все библиотеки, доступные языку Java.

    Функциональный стиль позволяет создавать HTTP обработчики в декларативном стиле \cite{decl}, что делает код
    легко
    читаемым, понятным даже тому, кто слабо знаком с языком. Это достигается именно за счет того, что синтаксис,
    применяемый в
    методах и
    алгоритмах, описанных на Scala, очень близок к тому, что используется в натуральных языках. \cite{declnat}

    Scala сильно отличается от ООП языков способом описания доменной логики. Под доменной логикой следует понимать
    ту часть кодовой базы приложения, которая непосредственно описывает алгоритмы работы приложения,
    которые могут быть описаны в спецификации,
    согласованные с клиентом, заказчиком.

    Основные отличия подхода, используемого в современной Scala, от ООП подхода следующие:
    \begin{enumerate}
        \item Все функции, за исключением, разве что, точки входа, являются чистыми.
        \item Сущности не имеют изменяемого внутреннего состояния, влияющего на их поведение.
        \item Функции, предполагающие взаимодействие с внешним миром, в частности, недетерминированные,
        мутирующие что-либо, имеют возвращаемый тип IO[A], где A - тип результата, а IO[A] представляет собой
        абстракцию над некоторой задачей.
    \end{enumerate}

    Есть множество библиотек, позволяющих создавать абстракции над задачами. Самые известные из них:

    \begin{enumerate}
        \item Cats Effect 2, Cats Effect 3 (CE2, CE3)
        \item ZIO 1, ZIO 2
        \item Monix
    \end{enumerate}

    Эти библиотеки предоставляют интерфейсы таких задач, механизмы их комбинации, параллельного и асинхронного связывания задач,
    а также их выполнения.
    В общем и целом приложение, написанное в подобном стиле, представляет собой
    сложную функцию, имеющую возвращаемый тип IO[A], то есть задачу, которая является абстракцией над всем приложеним,
    и последующее выполнение этой задачи на реальных потоках.
    На данный момент самыми продвинутыми библиотеками являются CE3 и ZIO 2.
    В этом проекте было решено использовать ZIO\cite{zio} в качестве основного функционального фреймворка.

    \section{Написание HTTP сервера на Scala}

    Для того, чтобы клиент мог взаимодействовать с приложением по сети, необходимо определиться с протоколом. В случае,
    когда нет необходимости в постоянном удерживании соединения между клиентом и сервисом и постоянным двунаправленным
    обменом сообщений, имеет смысл использовать протокол HTTP. HTTP-сервером называется приложение, способное обрабатывать
    входящие HTTP запросы.

    Инфраструктура HTTP сервера на Scala состоит из трех основных частей: язык описания контроллеров, HTTP движок, система
    связывания HTTP сервера и языка описания контроллеров.

    Рассмотрим устройство языка описания контроллеров. В Scala принято  разделять язык и логику, которая за ним стоит.

    Такой язык также принято называть DSL (англ. Domain-specific language). Впоследствии будем пользоваться именно этим термином.

    В создании DSL в первую очередь важны удобство, гибкость, надежность и
    предсказуемость. Некоторые из этих вещей, в частности надежность и предсказуемость, частично обеспечиваются строгой
    типизацией и
    неизменяемостью сущностей
    Но также важно, чтобы DSL не ограничивал возможности разработчиков, был гибок и универсален.


    Огромное значение стоит придать удобству описания новых сервисов, компактности нашего DSL.

    Теперь рассмотрим HTTP сервер. Под HTTP сервером можно понимать движок, который принимает входящий HTTP трафик, обрабатывает заголовки, содержимое,
    отвечает за поддержание соединения и решает прочие служебные задачи. Как правило, HTTP движок выступает некоторым посредником,
    который преобразует сетевые сигналы от операционной системы в некоторое внутреннее представление, которым можно удобно пользоваться
    в коде.

    При выборе HTTP сервера в первую очередь имеет смысл обращать внимание на 3 показателя:

    \begin{enumerate}
        \item HTTP сервер должен быть производительным.
        \item Он должен быть совместим с другими библиотеками, используемыми в проекте.
    \end{enumerate}

    \section{HTTP сервера в Scala}

    Есть множество библиотек, позволяющих реализовать HTTP сервер на Scala.

    Самые известные: Akka, Vert.X, Http4s, Finagle.

    \subsection*{Akka\cite{akkahttp}}
    Akka оказалась не подходящей, поскольку данный фреймворк является крайне устаревшим, использует в качестве ядра выполнения
    запросов такую концепцию как Future. Future более слабая абстракция над задачей, чем монада IO.
    Основные недостатки Future - отсутствие возможности прервать выполнение задачи, невозможность создать Future без немедленного выполнения
    самой задачи.

    Также, важным минусом Akka является то, что она не является самой быстрой библиотекой.

    С другой стороны Akka не лишена преимуществ: она совместима со множеством других библиотек, является крайне
    универсальной, а также предлагает богатые возможности для реализации акторной модели. (англ. Actor Model)

    \subsection*{Vert.X\cite{vertx}}
    Vert.X, вероятно, самая быстрая библиотека для Http сервера. Однако, она обладает одним огромным недостатком.
    Vert.X - пришла из Java, а потому имеет не очень высокую совместимость со Scala, с функциональной парадигмой.
    Vert.X слишком низкоуровневая библиотека, поэтому управлять ей, сохранив при этом корректный для Scala стиль программирования - очень трудно.

    \subsection*{Finagle\cite{finagle}}
    Крайне быстрая, универсальная библиотека, разработанная компанией Twitter. Но она, как и Vert.X, является очень
    низкоуровневой, процедурной. К тому же Finagle лишен богатой документации, которая присутствует у альтернатив.

    \subsection*{Http4s\cite{http4s}}
    Надежная, функциональная, удобная для использования библиотека. Однако, Http4s существенно уступает в производительности
    альтернативам.
    Именно поэтому, Http4s не принято использовать для высоконагруженных серверов.

    \subsection*{ZIO-Http\cite{ziohttp}}

    ZIO-Http новое, но пока не очень популярное в мире Scala решение,
    предоставляющее удобный
    функциональный
    интерфейс, а
    также, по проводимым сравнениям, обладающее очень высокой производительность.

    Было решено попробовать в качестве библиотеки для сервера ZIO-Http. Основная причин выбора: очень высокая
    совместимость с ZIO, новизна, высокая производительность.


    \section{Язык описания HTTP}

    В качестве библиотеки для описания DSL было решено использовать Tapir \cite{tapir}.

    Нельзя сказать, что это был лучший выбор, поскольку Tapir --- одна из тех библиотек, которая настаивает на том,
    чтобы разработчики, использующие её, придерживались тех абстракций, которые предлагает
    эта библиотека.

    Tapir --- не очень гибкое решение, и требует от разработчика, который захочет сделать на её основе свой DSL, больших
    стараний.

    Был альтернативный вариант --- Typed Schema \cite{ts}. (Одна из немногих HTTP DSL библиотек, совместимых с ZIO-http.)

    Эта библиотека, наоборот, является очень гибкой. Она позволяет практически любые DSL, представляет собой конструктор.
    Однако, главный минус Typed Schema --- сложность. Она требует от разработчика
    высокой подготовки, в то время как Tapir обещает простоту использования.

    Библиотека Tapir имеет крайне проработанную интеграцию с ZIO HTTP. То есть, существуют механизмы, позволяющие
    отображать язык описания Tapir в сервер ZIO http. Однако, здесь может возникнуть задача сделать такое отображение
    максимально удобным, чтобы код стал расширяемым, понятным.

    Основная сущность, которой оперирует Tapir это Endpoint:

    Endpoint - абстракция над HTTP обработчиком, сущностью, которая принимает входящие HTTP запросы и преобразует их
    во внутреннее представление. Фактически, endpoint представляет собой
    некоторое общее описание обработчика. То есть, тип метода (GET, POST), аргументы метода, тип возвращаемого результата, и так далее.

    Так выглядит конструктор класса Endpoint:

    \begin{verbatim}
        case class Endpoint[I, E, O, -R](input: EndpointInput[I],
            errorOutput: EndpointOutput[E],
            output: EndpointOutput[O],
            info: EndpointInfo)
    \end{verbatim}

    Endpoint описывает REST endpoint прослушивающего сервера.
    \begin{enumerate}
        \item I - тип сущности, которую прислал нам клиент
        \item E - тип бизнес ошибки, которая может прийти клиенту
        \item O - тип сущности, которую клиент получит от сервера в ответ на запрос
        \item R - тип контейнера, в котором переносятся данные
    \end{enumerate}

    Пример определения обработчика, который принимает два числа и возвращает строку:

    \begin{verbatim}
        private val sum = endpoint
            .in("sum")
            .in(query[Int]("x"))
            .in(query[Int]("y"))
            .out(stringBody)
    \end{verbatim}

    Логика здесь не описана. Фактически, tapir занимается лишь определением интерфейсов. Такой подход позволяет в том числе
    автоматически построить Swagger, документацию доступных HTTP методов нашего сервиса. Сама логика преобразования двух чисел в строку определяется отдельно.

    После создания EndPoint из Tapir, имеется возможность сконвертировать его в формат,
    используемый в сервере ZIO-Http.

    Для этого можно воспользоваться сущностью ZioHttpInterpreter, которая является частью библиотеки Tapir.

    Пример создания tapir endpoint и последующей конвертации его в ZIO HTTP Endpoint:

    \begin{verbatim}
    private val tapirEndpoint = endpoint
        .in("path")
        .in(query[Int]("x"))
        .in(query[Int]("y"))
        .out(stringBody)

    private val zioEndpoint = ZioHttpInterpreter().toHttp(tapirEndpoint) {
      case (x, y) => Task {
        Right((x + y).toString)
      }
    }
    \end{verbatim}

    После создания zioEndpoint, необходимо сделать вызов:

    \begin{verbatim}
        Server.start[Blocking](config.port, zioEndpoint)
    \end{verbatim}

    После этого запускается задача, принимающая входящие запросы, обрабатывающая их асинхронно и параллельно.

    \section{Модель авторизации}

    Для того, чтобы
    многопользовательские игры были
    возможны, необходимо уметь различать пользователей, взаимодействующих с системой,
    некоторым образом проверять, что это пользователь является тем, за кого себя выдает. Именно для этого необходима аутентификация.

    Также необходима авторизация, чтобы злоумышленники не мог вмешиваться в игровой процесс.

    Стоит также сказать о том, что процесс подтверждения личности должен быть децентрализованным. То есть каждый
    микросервис должен осуществлять этот процесс. Ведь каждая из реплик приложения должна уметь определять,
    кто с ней взаимодействует, предоставлять соответствующие права.

    Один из способов обеспечить такой механизм --- JWT токен. \cite{jwt}

    JWT токен --- некоторая информация, пописанная цифровой подписью с помощью симметричного шифрования.
    Для шифрования используется ключ, известный всем сервисам, но не известный внешним пользователям.
    Создание такого токена, как и проверка его
    достоверности, требует знания этого секретного ключа.

    JWT токен используется следующим образом:

    1) Один из экземпляров нашего API предоставляет клиентам методы регистрации и логина.

    2) После того, как клиент авторизовался в сервисе с помощью своих реквизитов (логин и пароль), для него генерируется новый вечный токен.
    Этот вечный токен помещается в базу данных, к которой имеют доступ все экземпляры API.

    3) С помощью этого токена он способен получить на любом другом экземпляре API свой JWT токен.

    4) JWT токен может быть использован как ключ, позволяющий сервисам идентифицировать пользователя и предоставить ему права.

    \subsection*{Причины использовать несколько токенов}

    В данной модели авторизации, можно было бы обойтись лишь одним токеном, но это
    повлекло бы за
    собой много минусов и ограничений.

    Обойтись только вечным токеном нельзя. Основная проблема состоит в том, что подтверждение достоверности представленного пользователем вечного токена
    осуществляется путем совершения запроса к базе данных, поскольку вечный токен хранится в базе.
    Был расчет на то, что каждый запрос к нашей системе
    должен сопровождаться подтверждением своей личности со стороны пользователя. То есть, каждое обращение
    пользователя к сервису вынуждало бы этот сервис обращаться к базе данных. Это увеличило бы время ответа системы на все
    запросы пользователя
    медленными и добавило бы лишнюю нагрузку на базу.

    Обойтись только лишь JWT токеном тоже нельзя. Если предположить, что в системе нет вечного токена и других промежуточных токенов, то пришлось бы получать JWT токен
    напрямую через логин и пароль. Основным недостатком здесь является то, что становится труднее контролировать сессии.
    В приведенной выше модели каждой сессии соответствует некоторый вечный токен. Если вечного токена нет - то и пользовательская
    сессия считается невалидной. Но в случае с паролем - нет возможности аннулировать сессию, не изменив пароль.
    К тому же, пришлось бы постоянно хранить пароль, либо его некоторую производную, например, хэш, на стороне клиента,
    что сделало бы модель менее безопасной. Ведь, заполучив эти данные, злоумышленники могли бы не только получить доступ
    к данному сервису, но и к другим сервисам, в которых пользователь также использовал данный пароль.

    JWT токен представляет собой строку, состоящую из трех частей.

    1) Метаинформация.
    Здесь описана некоторая информация вроде алгоритма шифрования.
    Обычно используется HS256.

    2) Данные.
    Здесь можно разместить любую информацию, которую необходимо обернуть в JWT токен и подписать.

    3) Сигнатура верификации.
    Это цифровая подпись. Она представляет собой некоторый набор символов, построенный API по данным
    с использованием приватного ключа, известного лишь сервису. С помощью сигнатуры верификации и публичного ключа, который
    известен всем, можно убедиться в том, что информация, обернутая в наш токен, не была подделана.

    Например, в рассматриваемом API в JWT токен оборачивается пара значений: идентификатор пользователя и время истечения токена.
    Таким образом,
    пользователь, обладающий таким токеном, может подтверждать свою личность
    (поскольку токен выдан на его имя). А время истечения токена позволяет достичь кратковременности таких
    токенов, то есть злоумышленник, получивший доступ к JWT токену, не сможет использовать его, начиная с некоторого момента.
    Попытка подделать время истечения приведет к порче токена, которую можно будет опознать с помощью цифровой подписи данных.

    JWT токен всё таки имеет некоторые недостатки. Основной недостаток состоит в том, что, получив доступ к базе данных, злоумышленник получит все вечные токены,
    а вместе с тем доступы всех клиентов, пользователей приложения.
    Один из действенных способов затруднить деятельность злоумышленников - хранить в базе данных не вечный токен, а
    его хэш. При чем, хэш может быть взят с некоторой солью, а соль может быть не универсальной. То есть, в базе данных
    для каждого пользователя хранится две строки: вечный токен и соль, с помощью которой он получен.

    Такой тип защиты называется bcrypt. В момент генерации вечного токена eternal, создается некоторая случайная строка - salt.
    Затем берется хэш от строки (eternal + salt) = hash, и в базу данных для пользователя записывается два значения: hash, salt.
    Затем, когда от пользователя приходит eternal токен, достаточно заполучить эти два значения hash, salt из базы данных
    по идентификатору пользователя, взять хэш от (eternal + salt) и сравнить с hash, полученным из базы данных.
    Если значения совпадают, считается, что пользователь прислал корректный eternal токен.

    \section{Реализация авторизации на стороне API}

    На стороне API нам предстояло реализовать несколько методов, позволяющих клиенту получить его JWT токен,
    чтобы с ним обращаться к другим микросервисам, доказывая свою подлинность.

    В API было решено выделить следующие методы:
    \begin{enumerate}
        \item registerEndpoint
        Клиент может зарегистрироваться (с некоторым логином и паролем).
        \item loginEndpoint
        Клиент может войти в систему (с некоторым логином и паролем).
        Он получает новый сгенерированный вечный токен.
        \item obtainEndpoint
        Клиент может получить JWT токен, воспользовавшись ранее полученным Eternal Token.
    \end{enumerate}

    Прежде чем провести аутентификацию и авторизацию клиента
    в игровом сервисе, клиенту необходимо зарегестрироваться
    в системе. Сделать он это может, предъявив логин и пароль.
    Для регистрации выделен отдельный метод register.

    \begin{verbatim}
        private val registerEndpoint: EndpointCollector =
            endpointE[RegisterError].post
            .in("register")
            .in(jsonBody[RegisterRequest])
            .build(req => service.registerUser(
                req.userName,
                req.password
            ))(_ => ())
    \end{verbatim}

    Логика, вызываемая в обработчике следующая:

    1) Валидируем формат пароля. Проверяем, что он имеет корректную длину,
    содержит корректные символы.

    2) Получаем хэш пароля.

    3) Генерируем случайный UUID, идентификатор нового пользователя.

    4) Пытаемся добавить в базу запись вида (UUID, login, password\_hash)

    Как только в базе появится соответствующая запись, клиент считается зарегестрированым,
    а логин занятым.

    Далее клиенту необходимо получить вечный токен. Для этого имеется метод
    login, который принимает на вход те же реквизиты (логин и пароль), и возвращает
    вечный токен.
    \newpage
    \subsection{Endpoint - Login}
    \begin{verbatim}
            private val loginEndpoint = endpointE[LoginError].post
                .in("login")
                .in(jsonBody[LoginRequest])
                .out(setCookies)
                .buildWithCookie(req => service.login(req.userName, req.password))(("eternal", _))
    \end{verbatim}

    Работает метод login следующим образом:

    1) Достает из базы UUID пользователя с таким логином, хэш его пароля.

    2) Проверяет, что пароль корректный, хэшируя его, сравнивая с хэшом из базы.

    3) Генерирует случайный вечный токен

    4) Помещает его в базу и возвращает пользователю.

    Далее, когда клиент имеет на руках вечный токен, у него появляется возможность
    запросить JWT токен. С помощью этого токена сервис уже сможет аутентифицировать и авторизовать клиента,
    предоставив ему доступ к игровым сессиям.

    Токен JWT получается с помощью метода obtain:

    \subsection{Endpoint - Obtain}
    \begin{verbatim}
            private val obtainEndpoint: EndpointCollector = endpointE[ObtainError].get
                .in("obtain_jwt")
                .in(cookie[EternalToken]("eternal"))
                .out(setCookies)
                .buildWithCookie(service.obtainSession)(("jwt", _))
    \end{verbatim}

    Метод работает следующим образом:

    1) Достает из базы UUID пользователя по вечному токену. На данном шаге
    наличие вечного токена у пользователя уже подтверждает его личность и позволяет
    системе предоставить ему доступ к JWT токену.

    2) Строит для этого пользователя JWT токен, а затем возвращает его.

    В итоге получается схема, в которой, чтобы начать играть, пользователь должен сначала
    зарегистрироваться методом Register, предоставив свой логин и пароль.

    Затем, воспользовавшись логином и паролем, он может обратиться к методу Login, получить длительную сессию, так
    называемый вечный токен.

    Процесс получения JWT состоит в том, что пользователь обращается к методу Obtain, передавая свой вечный токен,
    получает JWT токен, который предоставляет клиенту доступ к игровым сервисам.

    \section{Заключение}

    В ходе выполнения работы удалось изучить современные решения способов написания HTTP серверов без состояния на
    языке Scala.

    Также удалось поработать над моделью авторизации, изучить распространенные подходы к её описанию, попробовать
    реализовать её на практике.

    \begin{thebibliography}{99}
        \bibitem{scala}
        Scala [электронный ресурс] // Режим доступа \url{https://www.scala-lang.org} (дата обращения 31.01.2022)

        \bibitem{monad}
        Understanding IO Monad in Scala [электронный ресурс] // Режим доступа
        \url{https://medium.com/walmartglobaltech/understanding-io-monad-in-scala-b495ca572174}
        (дата обращения 31.01.2022)

        \bibitem{decl}
        Декларативный стиль [электронный ресурс] // Режим доступа \url{https://www.toptal.com/software/declarative-programming}
        (дата обращения 31.01.2022)

        \bibitem{declnat}
        Declarative Programming and Natural Language [электронный ресурс] // Режим доступа  \url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.456.7029&rep=rep1&type=pdf}
        (дата обращения 31.01.2022)

        \bibitem{zio}
        ZIO [электронный ресурс] // Режим доступа \url{https://github.com/dream11/zio-http} (дата обращения 31.01.2022)

        \bibitem{akkahttp}
        Akka HTTP [электронный ресурс] // Режим доступа \url{https://doc.akka.io/docs/akka-http/current/index.html} (дата обращения 31.01.2022)

        \bibitem{vertx}
        Vert.X [электронный ресурс] // Режим доступа \url{https://vertx.io/} (дата обращения 31.01.2022)

        \bibitem{finagle}
        Finagle [электронный ресурс] // Режим доступа \url{http://twitter.github.io/finagle/} (дата обращения 31.01.2022)

        \bibitem{http4s}
        Http4s [электронный ресурс] // Режим доступа \url{https://http4s.org/} (дата обращения 31.01.2022)

        \bibitem{ziohttp}
        ZioHTTP [электронный ресурс] // Режим доступа \url{https://github.com/dream11/zio-http} (дата обращения 31.01.2022)

        \bibitem{tapir}
        Tapir [электронный ресурс] // Режим доступа \url{https://github.com/softwaremill/tapir} (дата обращения 31.01.2022)

        \bibitem{ts}
        Typed schema [электронный ресурс] // Режим доступа \url{https://github.com/Tinkoff/typed-schema} (дата обращения 31.01.2022)

        \bibitem{jwt}
        JWT // Режим доступа
        \url{https://jwt.io/introduction}
        (дата обращения 31.01.2022)

    \end{thebibliography}

\end{document}